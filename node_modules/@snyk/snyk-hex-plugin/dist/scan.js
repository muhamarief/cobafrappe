"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scan = void 0;
const path = require("path");
const fs = require("fs");
const mix_parser_1 = require("@snyk/mix-parser");
const subProcess = require("./sub-process");
const debug_1 = require("./debug");
const MANIFEST_FILE_NAME = 'mix.exs';
async function scan(options) {
    debug_1.init(options.debug);
    const targetFile = path.parse(path.resolve(options.path, options.targetFile || MANIFEST_FILE_NAME));
    if (targetFile.base !== MANIFEST_FILE_NAME) {
        throw new Error("target file must be 'mix.exs'.");
    }
    const [, , mixResult] = await Promise.all([
        verifyHexInstalled(),
        verifyMixInstalled(),
        getMixResult(targetFile.dir),
    ]);
    const depGraphMap = mix_parser_1.buildDepGraphs(mixResult, !!options.dev, true);
    const scanResults = Object.entries(depGraphMap).map(([name, depGraph]) => {
        const isRoot = name === 'root';
        return {
            identity: {
                type: 'hex',
                targetFile: normalizePath(path.relative(options.path, path.resolve(targetFile.dir, isRoot ? '' : name, targetFile.base))),
            },
            facts: [
                {
                    type: 'depGraph',
                    data: depGraph,
                },
            ],
            ...(isRoot && options.projectName ? { name: options.projectName } : {}),
        };
    });
    return { scanResults };
}
exports.scan = scan;
async function verifyHexInstalled() {
    try {
        const hexInfo = await subProcess.execute('mix', ['hex.info']);
        debug_1.debug(`hex info: `, hexInfo);
    }
    catch (err) {
        throw new Error('hex is not installed. please run `mix local.hex` and try again.');
    }
}
async function verifyMixInstalled() {
    const mixVersion = await subProcess.execute('mix', ['-v']);
    debug_1.debug(`mix version: `, mixVersion);
}
async function getMixResult(root) {
    const cwd = path.join(__dirname, '../elixirsrc');
    let filePath;
    try {
        const output = await subProcess.execute('mix', ['read.mix', root], { cwd });
        debug_1.debug(`read.mix output: ${output}`);
        const fileName = output.trim().split('\n').pop();
        debug_1.debug(`fileName: ${fileName}`);
        filePath = path.resolve(cwd, fileName);
        const result = (await fs.promises.readFile(filePath, 'utf8'));
        return JSON.parse(result);
    }
    catch (err) {
        const errorMessage = `Error parsing manifest file on ${root}`;
        debug_1.debug(errorMessage, err);
        throw new Error(errorMessage);
    }
    finally {
        if (filePath) {
            await fs.promises
                .unlink(filePath)
                .catch((err) => debug_1.debug(`can't remove ${filePath}`, err));
        }
    }
}
function normalizePath(filePath) {
    const parts = filePath.split(path.sep);
    return parts.join(path.posix.sep);
}
//# sourceMappingURL=scan.js.map